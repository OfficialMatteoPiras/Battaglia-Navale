 //player::getCoords("corazzata 1");

    /*
    fleet.push_back(new submarine({"A10"}));
    fleet.push_back(new submarine({"B10"}));
    fleet.push_back(new submarine({"C10"}));

    defence.insert({"A10"}, 'E');
    defence.insert({"C10"}, 'E');
    defence.insert({"E10"}, 'E');

    std::cout << "-------- PLAYER 1 --------\n" << std::endl;
    game::grid(defence, attack);

    submarine *s = dynamic_cast <submarine*> ( fleet[0] );
    s->move({"N6"}, &defence);

    std::cout << "-------- PLAYER 1 --------\n" << std::endl;
    game::grid(defence, attack);

    free(s);
*/
    //TODO: INSERIRE LA NUMERAZIONE NEI MESSAGGI E FARE LA SEPARAZIONE DELLA STRINGA: FUNZIONE CHE TORNA PAIR<STRING, STRING>

    //CORAZZATE
    /*for (int i = 0; i < 3; ++i) {
        const coords c = getInputCoords("la corazzata");
        ships[i] = new battleship(c);
        //TODO: ad ogni ciclo inserisce la nave
    }
    //NAVI SUPPORTO
    for (int i = 0; i < 3; ++i) {
        const coords c = getInputCoords("la nave di supporto");
        ships[i] = new support(c);
        //TODO: ad ogni ciclo inserisce la nave
    }
    //SOTTOMARINO
    for (int i = 0; i < 3; ++i) {
        const coords c = getInputCoords("il sottomarino");
        ships[i] = new submarine(c);
        //TODO: ad ogni ciclo inserisce la nave
    }*/
    /*ships[0] = new submarine({"A10"});
    ships[1] = new submarine({"C10"});
    ships[2] = new submarine({"E10"});

    for (int i = 0; i < 3; ++i) {
        std::cout << ships[i]->getCenter() << std::endl;
    }
    defence.insert({"A10"}, 'E');
    defence.insert({"C10"}, 'E');
    defence.insert({"E10"}, 'E');

    std::cout << "-------- PLAYER 1 --------\n" << std::endl;
    game::grid(defence, attack);

    submarine *s = dynamic_cast <submarine*> ( ships[0] );
    s->move({"N6"}, &defence);

    std::cout << "-------- PLAYER 1 --------\n" << std::endl;
    game::grid(defence, attack);

    free(s);*/


/*
    for (int i = 0; i < 3; ++i) {
        coords c1 = game::getRandomCoord();
        bool vrt = game::getRandomInt(2) % 2 == 0;      //!to remove
        coords c2 = game::getRandomCoord(c1, vrt, 5);
        std::pair<coords, coords> input (c1, c2);
        std::cout << "input-> ";
        std::cout << input.first << " " << input.second << std::endl;

       // std::pair<coords, coords> input = getCoords("Quali sono le coordinate per la corazzata " + std::to_string(i));
        battleship newShip = getIstanceBattleship(input.first, input.second);
        fleet[newShip.getCenter()] = &newShip;
        std::cout << "new ship-> " << newShip.getCenter() << std::endl;
        std::cout << " ---------------- " << std::endl;
    }

    std::cout << "fleet size: " << fleet.size() << std::endl;

    for(auto it = fleet.cbegin(); it != fleet.cend(); ++it){
        std::cout << it->first.getRow() << it->first.getCol() << " " << it->second->getCenter() << std::endl;
    }
*/

   /* for(auto it = fleet.cbegin(); it != fleet.cend(); ++it) {
        std::cout << it->first.getX()<< " "<< it->first.getY() << " " << it->second->getCenter().getX()<< " " << it->second->getCenter().getX() << "\n";
    }*/


    //fleet.push_back({newShip.getCenter(), &newShip});
    //fleet[newShip.getCenter()] = &newShip;
    //fleet.insert(newShip.getCenter(), (ship*) &newShip);
    //fleet.insert(std::pair<coords, ship*>(newShip.getCenter(), (ship*) &newShip));

   /* for (auto itr = fleet.begin(); itr != fleet.end(); ++itr) {   //battleship
        //restituisce prua e poppa
        std::pair<coords, coords> input = getCoords("Quali sono le coordinate per la corazzata " + std::to_string(i));
        //ricavo il centro della nave
        //todo: creare un oggetto ship, convertire prua / poppa con centro ed inserire nella mappa
        auto newShip = getIstanceBattleship(input.first, input.second);
        fleet.insert(itr, {newShip.getCenter(), &newShip});
    }*/



/*
std::string player::getInputCoords(const std::string& message) {
    std::string newCoords;.
    std::cout << "Inserire le coordinate per " << message << "(poppa prua): ";
    std::cin >> newCoords;
    return {newCoords};
}*/

/*
ship player::getPlayerShip(coords coordsShip) {
    //return ship();
}

coords player::getShipCoords(ship playerShip) {
    return coords(0, 0);
}
*/
